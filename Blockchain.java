/* 1.0 2023-02-28 Shweta Kailas Kohinkar

Name: Shweta Kailas Kohinkar
Data: 2023-02-28
Java Version: 19.0.1

Running these programs:

Run this program on different terminals to start the multiple processes

Command-line compilation:
> javac -cp "gson-2.8.2.jar" Blockchain.java
> java -cp ".:gson-2.8.2.jar" Blockchain 0

To run on localhost:

> java -cp ".:gson-2.8.2.jar" Blockchain 0 : //By using this command, we can run the Blockchain code with process ID 0.
> java -cp ".:gson-2.8.2.jar" Blockchain 1 : //By using this command, we can run the Blockchain code with process ID 1.
> java -cp ".:gson-2.8.2.jar" Blockchain 2 : //By using this command, we can run the Blockchain code with process ID 2.
We can run multiple instances of this Blockchain program

Files needed: Blockchain.java, gson-2.8.2.jar, BlockInput0.txt, BlockInput1.txt, BlockInput3.txt

Notes:
1. This program runs multiple processes just need to change a single variable in the code.
2. It broadcasts updated verified block to the multiple processes and adds the multicasted block to the blockchain ledger.
3. Encryption and decryption of UUID and Hash is also included in this code.
4. CLI inputs are also added once the basic blockchain is executed:
    a. 'C' : input displays the blocks verified by process on which this input was given
    b. 'R' 'filename': input will read the files and create the blocks based on the data.
    c. 'V' : Verifies the entire blockchain
    d. 'V threshold' : Verifies whether the block's hash exceeds the threshold value.
    e. 'V invalid': Just and example to show if any block in blockchain is valid or not
    f. 'L' : Displays block-number, timestamp and data in descending order.

    Note for CLI: for these commands, it will print the statement in the process so after  all blocks are added just enter the input on the command.
*/

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import javax.crypto.Cipher;
import java.io.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;

/**
 * Main Blockchain Class which console input functions
 */
public class Blockchain {
    private static Map<Integer, PublicKey> publicKeyList = new HashMap<>(); // Map to store public keys of all the processes
    private static List<BlockRecord> BlockChainList = new ArrayList<>();     // Final blockchain list which will be filled by Blockchain server
    public final PriorityBlockingQueue<BlockRecord> unverifiedBlockChain =
            new PriorityBlockingQueue<>(100, BlockTSComparator); // Blocking queue to store the unverified blocks generated by
    // the Unverified Server

    public static int ProcessID;          // Stores the process id
    public static int LASTPROCESSID = 2;  // Used to identify the last process trigger
    //public static PrivateKey PRIVATEKEY;  // Storing the private key of each process globally
    public static boolean triggerProcess = false;  // to check if last process has triggered or not

    // implemented as a Singleton class
    private static Blockchain instance = new Blockchain();  // creating a single object of the class

    //so that this class cannot be instantiated, make the constructor private.
    private Blockchain() {
    }

    public static Blockchain getInstance() {
        return instance;
    }

    public List<BlockRecord> getBlockChainList() {
        return BlockChainList;
    }

    public void setBlockChainList(BlockRecord record) {
        BlockChainList.add(record);
    }

    /**
     * Comparator function to compare timestamps
     */
    public static Comparator<BlockRecord> BlockTSComparator = new Comparator<BlockRecord>() {
        @Override
        public int compare(BlockRecord b1, BlockRecord b2) {
            String s1 = b1.getTimeStamp();
            String s2 = b2.getTimeStamp();
            if (s1 == s2) {
                return 0;
            }
            if (s1 == null) {
                return -1;
            }
            if (s2 == null) {
                return 1;
            }
            return s1.compareTo(s2);
        }
    };

    public static Map<Integer, PublicKey> getPublicKeyList() {
        return publicKeyList;
    }

    public static void setPublicKeyList(Integer processId, PublicKey objPublicKey) {
        publicKeyList.put(processId, objPublicKey);
    }

    /**
     * Function to create dummy block
     *
     * @return
     */
    public String createDummyBlock() {
        BlockRecord record = new BlockRecord("This is a dummy block", Blockchain.ProcessID);
        record.setPreviousHash("0");   // setting previous hash as zero for dummy block
        record.setBlockNumber(0);
        return JSONFileHandler.getInstance().sendJsonObject(record);  // converting the block record into JSON
    }

    /**
     * Fucntion to trigger the other processes once the last process is started
     */
    public void triggerProcess() {
        try {
            PublicKeyClient objClientPublicKeyServer = new PublicKeyClient();
            UnverifiedBlockClient objClientUnverifiedBlock = new UnverifiedBlockClient();

            //Starting all clients once the last process is triggered
            objClientPublicKeyServer.run();
            objClientUnverifiedBlock.run();

            ConsoleInputHandler.getInstance().consoleInputs();  // to print the console inputs

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Function to start all the servers
     *
     * @param processId Takes the processId from the console
     */
    public void startServer(String processId) {
        try {
            Blockchain.ProcessID = Integer.parseInt(processId);   // takes the processid from the console

            PublicKeyServer publicKeyServer = new PublicKeyServer();
            UnverifiedBlockServer unverifiedBlockServer = new UnverifiedBlockServer(unverifiedBlockChain);
            BlockChainServer objBlockchainServer = new BlockChainServer();
            VerificationProcessHandler objVerificationProcess = new VerificationProcessHandler(unverifiedBlockChain);

            publicKeyServer.start();
            unverifiedBlockServer.start();
            objBlockchainServer.start();
            objVerificationProcess.start();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    /**
     * Main Function starts the servers
     *
     * @param argv
     * @throws InterruptedException
     */
    public static void main(String argv[]) throws InterruptedException {
        try {
            System.out.println("CLI inputs are also added once the basic blockchain is executed:\n" +
                    "    a. 'C' : input displays the blocks verified by process on which this input was given\n" +
                    "    b. 'R' 'filename': input will read the files and create the blocks based on the data.\n" +
                    "    c. 'V' : Verifies the entire blockchain<br>\n" +
                    "    d. 'V threshold' : Verifies whether the block's hash exceeds the threshold value.\n" +
                    "    e. 'V invalid': Just and example to show if any block in blockchain is valid or not.\n" +
                    "    f. 'L' : Displays block-number, timestamp and data in descending order.<br>\n" +

                    "    Note for CLI: for these commands, it will print the statement in the process so after  all blocks are added just enter the input on the command.\n");
            Blockchain objBlockChain = new Blockchain();
            objBlockChain.startServer(argv[0]);

            Thread.sleep(2000);

            // Check to trigger all the processes once the last process is triggered
            if (Blockchain.ProcessID == LASTPROCESSID) {
                MultiCast.getInstance().multiCastVerifiedBlock("localhost", objBlockChain.createDummyBlock(), 0);  // Broadcasting dummy blocks to all the processes
                MultiCast.getInstance().initProcess("localhost");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

/**
 * Console Input Function
 */
class ConsoleInputHandler{

    //Defined as singleton class
    private static ConsoleInputHandler instance = new ConsoleInputHandler();

    private ConsoleInputHandler(){}

    public static ConsoleInputHandler getInstance(){
        return instance;
    }

    /**
     * Function to take input from the console and display the output accordingly
     */
    public void consoleInputs() {
        try {
            String input = "";
            do {
                System.out.println("1. Enter C to get the count of blocks verified by the process.\n" +
                        "2. Enter R \"filename\" to read a file of records to create new data.\n" +
                        "3. Enter V or V \"invalid\" / \"threshold\"to verify the entire Blockchain and report errors if any.\n" +
                        "4. Enter L");

                Scanner scanner = new Scanner(System.in);
                System.out.flush();
                input = scanner.nextLine().toLowerCase();
                String fileName = "";
                if (input.startsWith("r")) {
                   try {
                       fileName = input.split(" ")[1];
                       input = input.split(" ")[0];
                   }
                   catch(Exception e)
                   {
                       System.out.println("Enter \"r filename\"");
                       continue;
                   }
                }
                if (input.contains(" ") && input.startsWith("v")) {
                    input = input.split(" ")[1];
                }
                switch (input) {
                    case "c":
                        countBlocks();
                        // System.out.println(String.format("Blocks verified by process %s are %s ", Blockchain.ProcessID, countBlocks())); // displays the blocks count verified by the process
                        continue;

                    case "r":   // adding new blocks to the blockchain
                        UnverifiedBlockClient objClientUnverifiedBlock = new UnverifiedBlockClient(fileName);
                        objClientUnverifiedBlock.run();

                        Thread.sleep(2000);

                        System.out.println("New blocks added to the blockchain");
                        continue;

                    case "v": // Verification of entire Blockchain
                        VerificationProcessHandler.verifyBlockchain();
                        continue;

                    case "threshold": // Verification of threshold
                        VerificationProcessHandler.verifyThreshold();
                        continue;

                    case "invalid":  // Verification of invalid threshold
                        VerificationProcessHandler.verifyInvalidThreshold();
                        continue;

                    case "l": // list all the block data with timestamp
                        listOutput();
                        continue;

                    default:
                        System.out.println("Enter proper input");
                        continue;
                }
            } while (input.indexOf("quit") < 0);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    /**
     * Returns the block count verified by the process
     * @return
     */
    public void countBlocks() {
        System.out.println("Verification Credit: ");
        for(int i = 0; i<=Blockchain.LASTPROCESSID;i++)
        {
            int val = i;
            System.out.println(String.format("P%s = %s ",i, Blockchain.getInstance().getBlockChainList().stream().filter(x -> x.getVerificationProcessID() == val).toList().size()));
        }
    }

    /**
     * Displays the list of all the block data with timepstamp
     */
    public void listOutput()
    {
        System.out.println("\n");
        for (int i = Blockchain.getInstance().getBlockChainList().size() - 1 ;i >=0; i--)
        {
            System.out.println(String.format("%s. %s %s", i, Blockchain.getInstance().getBlockChainList().get(i).getTimeStamp(),
                    Blockchain.getInstance().getBlockChainList().get(i).getData()));
        }
        System.out.println("\n");
    }
}

/**
 * Class BlockRecord - Structure of a block
 */
class BlockRecord implements Serializable {
    private String hash;
    private String winningHash;
    private String previousHash;
    private String data; //our data will be a simple message.
    private String timeStamp;
    private int blockNumber;
    private int processID;
    private String uuid;
    private String randomSeed;
    private String signedBlockID;
    private String signedWinningHash;
    private String signedHash;
    private String encryptedID;
    private String encryptedHash;
    private int verificationProcessID;

    BlockRecord(String _data, int _processId, PrivateKey key) {
        this.data = _data;
        this.timeStamp = String.valueOf(new Date().getTime());
        this.hash = getHashCode();
        this.uuid = UUID.randomUUID().toString();
        this.processID = _processId;
        this.signedBlockID = BlockUtility.getInstance().signData(uuid, key);
        this.signedHash = BlockUtility.getInstance().signData(hash, key);
        this.encryptedID = BlockUtility.getInstance().encrypt(uuid, key);
        this.encryptedHash = BlockUtility.getInstance().encrypt(hash,key);
    }

    //Constructor used for dummy block
    BlockRecord(String _data, int _processID)
    {
        this.data = _data;
        this.timeStamp = String.valueOf(new Date().getTime());
        this.hash = getHashCode();
        this.uuid = UUID.randomUUID().toString();
        this.processID = _processID;
        this.winningHash = hash;
    }

    public String getSignedWinningHash() {
        return signedWinningHash;
    }

    public void setSignedWinningHash(String signedWinningHash) {
        this.signedWinningHash = signedWinningHash;
    }

    public String getEncryptedID() {
        return encryptedID;
    }

    public void setEncryptedID(String encryptedID) {
        this.encryptedID = encryptedID;
    }

    public String getEncryptedHash() {
        return encryptedHash;
    }

    public void setEncryptedHash(String encryptedHash) {
        this.encryptedHash = encryptedHash;
    }

    public String getSignedHash() {
        return signedHash;
    }

    public String getWinningHash() {
        return winningHash;
    }

    public void setWinningHash(String winningHash) {
        this.winningHash = winningHash;
    }

    public void setSignedHash(String signedHash) {
        this.signedHash = signedHash;
    }

    public String getRandomSeed() {
        return randomSeed;
    }

    public void setRandomSeed(String randomSeed) {
        this.randomSeed = randomSeed;
    }

    public String getSignedBlockID() {
        return signedBlockID;
    }

    public void setSignedBlockID(String signedBlockID) {
        this.signedBlockID = signedBlockID;
    }
    public int getBlockNumber() {
        return blockNumber;
    }

    public void setBlockNumber(int blockNumber) {
        this.blockNumber = blockNumber;
    }

    public int getVerificationProcessID() {
        return verificationProcessID;
    }

    public void setVerificationProcessID(int verificationProcessID) {
        this.verificationProcessID = verificationProcessID;
    }

    public int getProcessID() {
        return processID;
    }

    public String getHash() {
        return hash;
    }

    public String getUuid() {
        return uuid;
    }

    public void setUuid(String uuid) {
        this.uuid = uuid;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    public String getPreviousHash() {
        return previousHash;
    }

    public void setPreviousHash(String previousHash) {
        this.previousHash = previousHash;
    }

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }

    public String getTimeStamp() {
        return timeStamp;
    }

    public void setTimeStamp(String timeStamp) {
        this.timeStamp = timeStamp;
    }

    public String getHashCode() {
        return BlockUtility.getInstance().generateHashCode(previousHash + processID + blockNumber + data);
    }
}

/**
 * Class for port numbers
 */
class Ports{
    public static int KEYSERVER = 4710;
    public static int UNVERIFIEDBLOCKSERVER = 4820;
    public static int BLOCKCHAINSERVER = 4930;
}

/**
 * Serialized class to send over the network
 */
class PublicKeyRec implements Serializable{
    PublicKey publicKey;
    int processId;
}

/**
 * Class used to multicast the blocks to all over processes
 */
class MultiCast{
    private static MultiCast instance = new MultiCast();

    private MultiCast(){}

    public static MultiCast getInstance(){
        return instance;
    }

    /**
     * Function used to trigger the processes
     * @param serverName
     */
    public void initProcess(String serverName){
        try {
            for (int i = 0; i <= Blockchain.LASTPROCESSID; i++) {
                Socket keySocket = UtilitySocket.getInstance().getSocket(serverName, Ports.KEYSERVER + i);
                keySocket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Function to broadcast public key to all public key servers
     * @param objPublicKeyRec
     * @param serverName
     */
    public void multiCastPublicKey(PublicKeyRec objPublicKeyRec, String serverName) {
        try {
            for (int i = 0; i <= Blockchain.LASTPROCESSID; i++) {
                Socket keySocket = new Socket();
                keySocket = UtilitySocket.getInstance().getSocket(serverName, Ports.KEYSERVER + i);
                ObjectOutputStream objOutStream = UtilitySocket.getInstance().formOutputConnection(keySocket);
                objOutStream.writeObject(objPublicKeyRec);
                System.out.println(String.format("Public key of process Id %s is broadcast to process %s", Blockchain.ProcessID, i));
                keySocket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Function to broadcast unverified blocks to all unverified block servers
     * @param serverName
     * @param jsonData
     */
    public void multiCastUVB( String serverName, String jsonData) {
        try {
            for (int i = 0; i <= Blockchain.LASTPROCESSID; i++) {
                Socket keySocket = new Socket();
                keySocket = UtilitySocket.getInstance().getSocket(serverName, Ports.UNVERIFIEDBLOCKSERVER + i);
                ObjectOutputStream objOutStream = UtilitySocket.getInstance().formOutputConnection(keySocket);
                System.out.println(String.format("Broadcasting UV block to the UV Server of process %s...!!!",i));
                objOutStream.writeObject(jsonData);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Function to broadcast verified blocks to all blockchain servers
     * @param serverName
     * @param blockNum
     */
    public void multiCastVerifiedBlock(String serverName, String jsonData, int blockNum) {
        try {
            for (int i = 0; i <= Blockchain.LASTPROCESSID; i++) {
                Socket keySocket = new Socket();
                keySocket = UtilitySocket.getInstance().getSocket(serverName, Ports.BLOCKCHAINSERVER + i);
                ObjectOutputStream objOutStream = UtilitySocket.getInstance().formOutputConnection(keySocket);
                objOutStream.writeObject(jsonData);
                System.out.println(String.format("Verified block number %s of process %s is broadcasted to process %s", blockNum, Blockchain.ProcessID, i));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

/**
 * Class defined for BlockUtilities
 */
class BlockUtility {

    private static BlockUtility instance = new BlockUtility();

    private BlockUtility() {
    }

    public static BlockUtility getInstance() {
        return instance;
    }

    /**
     * Function to generate hash code for the block using SHA-256 Algorithm
     * @param getHashStr
     * @return
     */
    public String generateHashCode(String getHashStr) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] byteData = digest.digest(getHashStr.getBytes("UTF-8"));

            StringBuffer hexStr = new StringBuffer(); //hexadecimal hash
            for (int i = 0; i < byteData.length; i++) {
                String hex = Integer.toHexString(0xff & byteData[i]);
                if (hex.length() == 1) {
                    hexStr.append('0');
                }
                hexStr.append(hex);
            }
            return hexStr.toString();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Function to encrypt the data using Private Key
     * @param text
     * @param key
     * @return
     */
    public String encrypt(String text, PrivateKey key) {
        try {
            final Cipher cipher = Cipher.getInstance("RSA"); // Get RSA cipher object
            cipher.init(Cipher.ENCRYPT_MODE, key);           // Use private key to encrypt the data
            return Base64.getEncoder().encodeToString(cipher.doFinal(text.getBytes(StandardCharsets.UTF_8)));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Function to decrypt the data using Public Key
     * @param text
     * @param key
     * @return
     */
    public String decrypt(String text, PublicKey key) {
        try {

            final Cipher cipher = Cipher.getInstance("RSA");

            cipher.init(Cipher.DECRYPT_MODE, key);
            return new String(cipher.doFinal(Base64.getDecoder().decode(text)));

        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    /**
     * Creating Signature of the data
     * @param text
     * @return
     */
    public String signData(String text, PrivateKey key) {
        try {
            Signature sign = Signature.getInstance("SHA1WithRSA");
            sign.initSign(key);
            byte[] dataBytes = text.getBytes(StandardCharsets.UTF_8);
            sign.update(dataBytes);
            return Base64.getEncoder().encodeToString(sign.sign());
        } catch (NoSuchAlgorithmException | InvalidKeyException | SignatureException e) {
            e.printStackTrace();
        }
        return null;
    }


    /**
     * Verify signed data with public key
     * @param text
     * @param signedData
     * @param publicKey
     * @return
     */
    public boolean verifySign(String text, String signedData, PublicKey publicKey) {
        try {
            Signature sign = Signature.getInstance("SHA1WithRSA");
            sign.initVerify(publicKey);
            byte[] dataBytes = text.getBytes(StandardCharsets.UTF_8);
            sign.update(dataBytes);
            return sign.verify(Base64.getDecoder().decode(signedData));
        } catch (NoSuchAlgorithmException | InvalidKeyException | SignatureException e) {
            e.printStackTrace();
        }
        return false;
    }
}

/**
 * Class defined to handle file operations
 */
class FileDataForProcess{
    private static FileDataForProcess instance = new FileDataForProcess();

    private FileDataForProcess(){}

    public static FileDataForProcess getInstance(){
        return instance;
    }

    /**
     * Function to read input files
     * @param fileNum
     * @param fileName
     * @return
     */
    public List<String> readInputFiles(int fileNum, String fileName) {
        try {
            if(fileName=="") {
                return Files.readAllLines(Paths.get("BlockInput" + fileNum + ".txt"));
            }
            return Files.readAllLines(Paths.get(fileName));

        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
}

/**
 * JSON File Operation Handler Class
 */
class JSONFileHandler {
    private static JSONFileHandler instance = new JSONFileHandler();

    private JSONFileHandler(){}

    public static JSONFileHandler getInstance(){
        return instance;
    }

    /**
     * Function to write a JSON file
     * @param blockChainList
     * @param id
     */
    public void writeJSONFile(List<BlockRecord> blockChainList, int id) {
        try {
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            FileWriter fileWriter = new FileWriter("BlockchainLedger.json");
           //Convert Java Object to JSON File
            gson.toJson(blockChainList, fileWriter);
            fileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Function to read a JSON file
     * @return BlockRecord
     */
    public BlockRecord readJSONFile() {
        try {
            Gson gson = new Gson();
            FileReader reader = new FileReader("BlockchainLedgerSample.json");
            // Read and convert JSON File to a Java Object:
            return gson.fromJson(reader, BlockRecord.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Function to convert Java object to JSON format
     * @param _record
     * @return
     */
    public String sendJsonObject(BlockRecord _record) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.toJson(_record);
    }

    /**
     * Function to convert JSON String to Java Object
     * @param jsonData
     * @return
     */
    public BlockRecord readJsonObject(String jsonData) {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        return gson.fromJson(jsonData, BlockRecord.class);
    }
}

/**
 * Class defined for Socket Utilities
 */
class UtilitySocket{
    private static UtilitySocket instance = new UtilitySocket();

    private UtilitySocket(){}

    public static UtilitySocket getInstance(){
        return instance;
    }

    /**
     * Function to open a serversocket connection
     * @param port
     * @param q_len
     * @return
     */
    public ServerSocket getServerSocket(int port, int q_len)
    {
        ServerSocket serverSocket = null;
        try {
            serverSocket = new ServerSocket(port, q_len);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return serverSocket;
    }

    /**
     * Function to open a Socket connection form a client side
     * @param serverName
     * @param port
     * @return
     */
    public Socket getSocket(String serverName, int port)
    {
        Socket socket = null;
        try {
            socket = new Socket(serverName, port);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return socket;
    }


    /**
     * Function to get an object for ObjectOutputStream
     * @param socket
     * @return
     */
    public ObjectOutputStream formOutputConnection(Socket socket) {
        try {
            OutputStream outStream = socket.getOutputStream();                   // Creating an output stream object
            ObjectOutputStream objOutStream = new ObjectOutputStream(outStream); // Used for Serializing an output stream which is to be sent
            return objOutStream;
        } catch (IOException IOE) {
            IOE.printStackTrace();      // prints an error message on the terminal/console
            return null;
        }
    }

    /**
     * Function to get an object for ObjectInputStream
     * @param socket
     * @return
     */
    public ObjectInputStream formInputConnection(Socket socket) {
        try {
            InputStream inStream = socket.getInputStream();                  // Getting an input stream from the socket
            ObjectInputStream objInStream = new ObjectInputStream(inStream); // Used for Deserializing an input stream
            return objInStream;
        } catch (IOException IOE) {
            IOE.printStackTrace();      // prints an error message on the terminal/console
            return null;
        }
    }
}

/**
 * Class defined for public key server to open a socket connection on port 4710, 4711, 4712,...
 */
class PublicKeyServer extends Thread {
    public void run() {
        int q_len = 6;
        Socket sock;
        System.out.println(String.format("Starting the Blockchain Key Server input thread using %s...!!! ", (Ports.KEYSERVER + Blockchain.ProcessID)));
        try {
            ServerSocket keyServerSocket = UtilitySocket.getInstance().getServerSocket(Ports.KEYSERVER + Blockchain.ProcessID, q_len);
            while (true) {
                sock = keyServerSocket.accept();    // Listens for client connection

                new PublicKeyWorker(sock).start();
            }
        } catch (IOException ioe) {
            System.out.println(ioe);
        }
    }
}

/**
 * Class defined to accept the Public key sent by the Clients of all the processes and store them to a map
 */
class PublicKeyWorker extends Thread { // Spawning Worker thread so that it can process all the public keys
    Socket keySock;

    PublicKeyWorker(Socket s) {
        keySock = s;}

    public void run() {
        try {
            if(!Blockchain.triggerProcess) {
                Blockchain.triggerProcess = true;
                Blockchain.getInstance().triggerProcess();   //  once the last process is triggered the other processes continues their execution
            } else{
                ObjectInputStream objInStream = UtilitySocket.getInstance().formInputConnection(keySock);
                PublicKeyRec key = (PublicKeyRec) objInStream.readObject();
                Blockchain.setPublicKeyList(key.processId, key.publicKey);
                System.out.println(String.format("Public key received by the server %s", Ports.KEYSERVER + key.processId));
                keySock.close();
            }
        } catch (IOException |ClassNotFoundException x) {
            x.printStackTrace();
        }
    }
}

/**
 * Class defined to generate public key and broadcast it to all other processes including itself
 */
class PublicKeyClient {

    String serverName = "localhost";

    static PrivateKey PRIVATEKEY;


    /**
     * Function to generate and broadcast public key
     */
    public void run() {
        try {
            PublicKeyRec objPublicKeyRec = new PublicKeyRec();
            KeyPair objKeyPair = KeyPairGenerator(0);    // KeyPair generation method call
            PRIVATEKEY = objKeyPair.getPrivate();  // Storing this private key in a global variable

            // Storing public key and process id into an object
            objPublicKeyRec.publicKey = objKeyPair.getPublic();
            objPublicKeyRec.processId = Blockchain.ProcessID;

            //Multicasting the Java object which includes Public key and process ID to all processes
            MultiCast.getInstance().multiCastPublicKey(objPublicKeyRec, serverName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Function to generate keyPair using RSA algorithm
     * @param seed
     * @return
     * @throws Exception
     */
    public static KeyPair KeyPairGenerator(long seed) throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        SecureRandom rng = SecureRandom.getInstance("SHA1PRNG", "SUN");
        rng.setSeed(seed);
        keyPairGenerator.initialize(4096, rng);
        return (keyPairGenerator.generateKeyPair());
    }
}


/**
 * Class defined to start Unverified server on ports 4810, 4811, 4812,...
 */
class UnverifiedBlockServer extends Thread { // Worker thread to process incoming public keys
    PriorityBlockingQueue<BlockRecord> queue;
    UnverifiedBlockServer(PriorityBlockingQueue<BlockRecord> _queue) {
        queue = _queue; // Constructor binds our prioirty queue to the local variable.
    }

    /**
     * Function defined to start server
     */
    public void run(){
        int q_len = 6;
        Socket sock;
        System.out.println(String.format("Starting the Blockchain Unverified Server input thread using %s...!!! " , Integer.toString(Ports.UNVERIFIEDBLOCKSERVER + Blockchain.ProcessID)));
        try{
            ServerSocket keyServerSocket = UtilitySocket.getInstance().getServerSocket(Ports.UNVERIFIEDBLOCKSERVER + Blockchain.ProcessID, q_len);
            while (true) {
                sock = keyServerSocket.accept();   // Listens for client connection
                new UnverifiedBlockWorker(sock, queue).start();  // spawns worker thread
            }
        }catch (IOException ioe) {
            System.out.println(ioe);
        }
    }
}

/**
 * Class defined to add generated blocks to the priority queue
 */
class UnverifiedBlockWorker extends Thread {
    Socket keySock;
    BlockingQueue<BlockRecord> queue;
    UnverifiedBlockWorker(Socket s, BlockingQueue<BlockRecord> _queue) {
        keySock = s;
        queue = _queue;
    }

    /**
     * Function used to add received blocks to the queue
     */
    public void run() {
        try {
            ObjectInputStream objInStream = UtilitySocket.getInstance().formInputConnection(keySock);
            String jsonData = (String) objInStream.readObject();
            BlockRecord record = JSONFileHandler.getInstance().readJsonObject(jsonData); // converting received JSON string into BlockRecord ie. Java Object
            queue.put(record);
            keySock.close();
        } catch (IOException x) {
            x.printStackTrace();
        } catch (ClassNotFoundException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}

/**
 * Class defined to read an input file and convert the data into blocks
 */
class UnverifiedBlockClient {
    String serverName = "localhost";
    String fileName = "";

    UnverifiedBlockClient(String _fileName)
    {
        fileName = _fileName;
    }
    UnverifiedBlockClient(){}

    public void run()
    {
        try {
            Thread.sleep(1000);
            String jsonData;
            List<String> fileData =  FileDataForProcess.getInstance().readInputFiles(Blockchain.ProcessID, fileName);  // Reading input file
            System.out.println(String.format("UnverifiedBlock for process %s ", Blockchain.ProcessID));
            for(String data : fileData){
                BlockRecord blockRecord = new BlockRecord(data, Blockchain.ProcessID, PublicKeyClient.PRIVATEKEY);
                jsonData = JSONFileHandler.getInstance().sendJsonObject(blockRecord);
                MultiCast.getInstance().multiCastUVB(serverName,jsonData);    // multicasting block to all other processes
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

/**
 * Class defined to start the Blockchain servers 4930, 4931, 4932,...
 */
class BlockChainServer extends Thread {
    public void run() {
        int q_len = 6;
        Socket sock;
        System.out.println(String.format("Starting the Blockchain Server input thread using %s...!!!", Integer.toString(Ports.BLOCKCHAINSERVER + Blockchain.ProcessID)));
        try {
            ServerSocket keyServerSocket = UtilitySocket.getInstance().getServerSocket(Ports.BLOCKCHAINSERVER + Blockchain.ProcessID, q_len);
            while (true) {
                sock = keyServerSocket.accept();  // Listens for client connection
                new BlockChainWorker(sock).start(); // spawns worker thread
            }
        } catch (IOException ioe) {
            System.out.println(ioe);
        }
    }
}

/**
 * Class defined to add verified block to the final blockchain list
 */
class BlockChainWorker extends Thread { // Worker thread to process incoming public keys
    Socket keySock; // Class member, socket, local to Worker.
    BlockingQueue<BlockRecord> queue;
    BlockChainWorker(Socket s) {
        keySock = s;
    } // Constructor, assign arg s to local sock

    public void run() {
        try {
            ObjectInputStream objInStream = UtilitySocket.getInstance().formInputConnection(keySock);   // getting an input stream
            String jsonData = (String) objInStream.readObject();                                        // Reading JSOn string from the network
            BlockRecord record = JSONFileHandler.getInstance().readJsonObject(jsonData);                // Converting JSON object to a JAVA object
            List<BlockRecord> localCopy = Blockchain.getInstance().getBlockChainList();// Creating a local copy of a blockchain list

            if (VerificationProcessHandler.checkUUID(localCopy, record)) {              // Checking if UUID is already present in a blockchain or not
                Blockchain.getInstance().setBlockChainList(record);
                System.out.println(String.format("Block number %s verified by process %s added to the blockchain list...!!!", record.getBlockNumber(), record.getVerificationProcessID()));
                // If not add it to the blockchain list
                //localCopy.add(record);
            } else {                                            // if UUID is present then consider the block with the lowest timestamp
                BlockRecord rec = Blockchain.getInstance().getBlockChainList().
                        stream().filter(x -> x.getUuid().equals(record.getUuid())).findFirst().get();
                if (rec.getTimeStamp().compareTo(record.getTimeStamp()) > 0 || (rec.getTimeStamp().compareTo(record.getTimeStamp()) == 0 && rec.getVerificationProcessID() < record.getVerificationProcessID())) {
                    Blockchain.getInstance().getBlockChainList().remove(rec);
                    Blockchain.getInstance().getBlockChainList().add(record);
                    System.out.println(String.format("Block number %s verified by process %s added to the blockchain list...!!!", record.getBlockNumber(), record.getVerificationProcessID()));
                }
            }
            localCopy = new ArrayList<>(Blockchain.getInstance().getBlockChainList());
            if (Blockchain.ProcessID == 0) {
                JSONFileHandler.getInstance().writeJSONFile(localCopy, Blockchain.ProcessID);        // Writing a JSON file by process 0
            }
            System.out.println("Size of BlockChain: " + localCopy.size());


            keySock.close();
        }catch (IOException | ClassNotFoundException x) {
            x.printStackTrace();
        }
    }
}

/**
 * Class defined to broadcast the verified block to all other servers of the processes
 */
class BlockchainClient {
    String serverName = "localhost";
    String jsonData = "";
    int blockNumber;

    BlockchainClient(String _jsonData, int blockNum) {
        jsonData = _jsonData;
        blockNumber = blockNum;
    }

    public void run() {
        try {
            MultiCast.getInstance().multiCastVerifiedBlock(serverName, jsonData, blockNumber);  // broadcasting a block to all processed
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

/**
 * Class defined to verify the blocks in from the priority queue
 */
class VerificationProcessHandler extends Thread{

    BlockingQueue<BlockRecord> queue;
    private static final String ALPHA_NUMERIC_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    VerificationProcessHandler(BlockingQueue<BlockRecord> _queue)
    {
        queue = _queue; // Constructor binds our prioirty queue to the local variable.
    }

    /**
     * Function to verify the block
     */
    public void run() {
        try {
            Socket keySocket = new Socket();
            while(true) {
                BlockRecord record = queue.take();      // takes the block from the priority queue
                if (VerificationProcessHandler.checkUUID(Blockchain.getInstance().getBlockChainList(), record)) {              // Checking if UUID is already present in a blockchain or not
                    if (verifySignedUuid(record) && verifySignedHash(record) && verifyEncrpytedUuid(record) && verifyEncryptedHash(record)) {  // verify UUID and signed HASH
                        record.setBlockNumber(Blockchain.getInstance().getBlockChainList().size());  // setting block number to the block
                        record.setVerificationProcessID(Blockchain.ProcessID);   // setting verification process id to the block
                        System.out.println(String.format("Block %s is getting verified by process %s", record.getBlockNumber(), record.getVerificationProcessID()));

                        record.setTimeStamp(String.valueOf(new Date().getTime()));  // setting verification timestamp
                        //Setting previous hash
                        record.setPreviousHash(Blockchain.getInstance().getBlockChainList().size() == 0 ? "0" :
                                Blockchain.getInstance().getBlockChainList().get(Blockchain.getInstance().getBlockChainList().size() - 1).getWinningHash());

                        if (VerifyConcatenatedHash(record)) { // Solving work puzzle
                            System.out.println(String.format("Verification of block %s completed...!!!", record.getBlockNumber()));

                            if (Blockchain.getInstance().getBlockChainList().size() == record.getBlockNumber()) {
                                //Send data in JSON format
                                BlockchainClient clientBlockchain = new BlockchainClient(JSONFileHandler.getInstance().sendJsonObject(record), record.getBlockNumber());
                                clientBlockchain.run();
                            } else {
                                queue.put(record);  //
                            }
                        } else {
                            queue.put(record);
                        }
                    }
                    Thread.sleep(500);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Function to generate a random string value
     * @param count
     * @return
     */
    public static String generateRandomSeed(int count) {

        StringBuilder builder = new StringBuilder();
        while (count-- != 0) {
            int character = (int)(Math.random() * ALPHA_NUMERIC_STRING.length());
            builder.append(ALPHA_NUMERIC_STRING.charAt(character));
        }
        return builder.toString();
    }

    /**
     * Function to verify concatenated hash and solve the work puzzle
     * @param _record
     * @return
     */
    private boolean VerifyConcatenatedHash(BlockRecord _record)
    {
        String concatenatedStr = "";
        for(int i = 1; i < 20; i++) {
            _record.setRandomSeed(generateRandomSeed(8));
            concatenatedStr = createConcatenatedString(_record);    // Create a Concatenated hash using various parameters
            String hashToVerify = BlockUtility.getInstance().generateHashCode(concatenatedStr); // Generate hash for the concatenated string
            if(solvePuzzle(hashToVerify))// verifying threshold value
            {
                _record.setWinningHash(hashToVerify);
                return true;
            }
        }
        return false;
    }

    /**
     * Funciton to solve the puzzle using some threshold value
     * @param hashToVerify
     * @return
     */
    public static boolean solvePuzzle(String hashToVerify )
    {
        int workNumber = Integer.parseInt(hashToVerify.substring(0, 4), 16);
        return workNumber < 10000;
    }

    /**
     * Function to create a concatenated String
     * @param _record
     * @return
     */
    public static String createConcatenatedString(BlockRecord _record)
    {
        return _record.getHash() + _record.getPreviousHash() + _record.getBlockNumber() + _record.getVerificationProcessID() +
                _record.getTimeStamp() + _record.getRandomSeed();
    }

    /**
     * Function to verify UUID from encrypted signed ID
     * @param _record
     * @return
     */
    private static boolean verifySignedUuid(BlockRecord _record)
    {
       return BlockUtility.getInstance().verifySign(_record.getUuid(), _record.getSignedBlockID(),
               Blockchain.getPublicKeyList().get(_record.getProcessID()));
    }

    /**
     * Fucntion to verify Signed Hash
     * @param _record
     * @return
     */
    private static boolean verifySignedHash(BlockRecord _record)
    {
        return BlockUtility.getInstance().verifySign(_record.getHash(), _record.getSignedHash(),
                Blockchain.getPublicKeyList().get(_record.getProcessID()));
    }

    /**
     * Fucntion to verify Signed Winning Hash
     * @param _record
     * @return
     */
    private static boolean verifySignedWinningHash(BlockRecord _record)
    {
        return BlockUtility.getInstance().verifySign(_record.getWinningHash(), _record.getSignedWinningHash(),
                Blockchain.getPublicKeyList().get(_record.getVerificationProcessID()));
    }

    /**
     * Function to verify UUID from encrypted signed ID
     * @param _record
     * @return
     */
    private static boolean verifyEncrpytedUuid(BlockRecord _record)
    {
        return _record.getUuid().equals( BlockUtility.getInstance().decrypt(_record.getEncryptedID(),
                Blockchain.getPublicKeyList().get(_record.getProcessID())));
    }

    /**
     * Fucntion to verify Signed Hash
     * @param _record
     * @return
     */
    private static boolean verifyEncryptedHash(BlockRecord _record)
    {
        return _record.getHash().equals( BlockUtility.getInstance().decrypt(_record.getEncryptedHash(), Blockchain.getPublicKeyList().get(_record.getProcessID())));
    }

    /**
     * Function to verify entire blockchain
     * @return
     */
    public static boolean verifyBlockchain() {
        try {
            for (BlockRecord blockRecord : Blockchain.getInstance().getBlockChainList()) {
                if (blockRecord.getBlockNumber() != 0) {
                    String concatenatedHash = BlockUtility.getInstance().generateHashCode(createConcatenatedString(blockRecord));
                    if (!(blockRecord.getWinningHash().equals(concatenatedHash) && solvePuzzle(concatenatedHash) 
                            && verifySignedUuid(blockRecord) &&verifyEncrpytedUuid(blockRecord) && verifyEncryptedHash(blockRecord))) {
                        System.out.println(String.format("Block %s is invalid. So all the blocks after this block are invalid ", blockRecord.getBlockNumber()));
                        return false;
                    }
                }
            }
            System.out.println("Verification of entire blockchain was successful...!!!");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    public static boolean checkUUID(List<BlockRecord> localCopy, BlockRecord record){
       return localCopy.stream().noneMatch(x -> x.getUuid().equals(record.getUuid()));
    }

    /**
     * Function to verify threshold
     */
    public static void verifyThreshold() {
        try {
            for (BlockRecord blockRecord : Blockchain.getInstance().getBlockChainList()) {
                if (blockRecord.getBlockNumber() != 0) {
                    String concatenatedHash = BlockUtility.getInstance().generateHashCode(createConcatenatedString(blockRecord));
                    if (!(blockRecord.getWinningHash().equals(concatenatedHash))) {
                        if (!solvePuzzle(concatenatedHash)) {
                            if (blockRecord.getBlockNumber() != (Blockchain.getInstance().getBlockChainList().size() - 1)) {
                                System.out.println(String.format("Blockchain size %s\n ", Blockchain.getInstance().getBlockChainList()));
                                System.out.println(String.format("Block %s invalid: SHA256 is confirmed, but doesn't meet threshold.\n " +
                                                "\nBlocks %s - %s follow an invalid block ", blockRecord.getBlockNumber(), (blockRecord.getBlockNumber() + 1),
                                        (Blockchain.getInstance().getBlockChainList().size() - 1)));
                            } else {
                                System.out.println(String.format("Block %s invalid: SHA256 is confirmed, but doesn't meet threshold.\n ", blockRecord.getBlockNumber()));
                            }

                        }
                    }
                }
            }
            System.out.println("Threshold for each block was verified...!!!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Function defined to check for invalid threshold
     */
    public static void verifyInvalidThreshold() {
        try {
            Random random = new Random();
            BlockRecord blockRecord = Blockchain.getInstance().getBlockChainList().get(random.nextInt(Blockchain.getInstance().getBlockChainList().size()));
            if (blockRecord.getBlockNumber() != (Blockchain.getInstance().getBlockChainList().size() - 1)) {
                System.out.println(String.format("Blockchain size %s\n ", Blockchain.getInstance().getBlockChainList().size()));
                System.out.println(String.format("Block %s invalid: SHA256 is confirmed, but doesn't meet threshold.\n " +
                                "\nBlocks %s - %s follow an invalid block ", blockRecord.getBlockNumber(), (blockRecord.getBlockNumber() + 1),
                        (Blockchain.getInstance().getBlockChainList().size() - 1)));
            } else {
                System.out.println(String.format("Block %s invalid: SHA256 is confirmed, but doesn't meet threshold.\n ", blockRecord.getBlockNumber()));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

